// Test if a new solution can be added for contract - SolnSquareVerifier

// Test if an ERC721 token can be minted for contract - SolnSquareVerifier

// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates



const truffleAssert = require('truffle-assertions')
var SolnSquareVerifier = artifacts.require('./SolnSquareVerifier');
var proof = require('/Users/iSh3lan/Udacity/Block Chain/Project 9/Blockchain-Capstone-master/zokrates/code/square/proof');
contract('SolnSquareVerifier', accounts => {

    const account_one = accounts[0];
    const account_two = accounts[1];

    describe('SolnSquareVerifier test', function () {
        beforeEach(async function () {
            this.contract = await SolnSquareVerifier.new({from: account_one});

        })
        it('Tests adding solution and minting', async function () {

          let A = proof.proof.A;
          let A_p = proof.proof.A_p;
          let B = proof.proof.B;
          let B_p = proof.proof.B_p;
          let C = proof.proof.C;
          let C_p = proof.proof.C_p;
          let H = proof.proof.H;
          let K = proof.proof.K;
          let input = proof.input;

          let check = await this.contract.addSolutionAndMint(A,A_p,B,B_p,C,C_p,H,K,input,account_one,1001);

          /////////////////////////////////// test if solution can be added////////////////////////////////////////////////////////////////
          truffleAssert.eventEmitted(check, 'solutionAdded');
          let check1 = await this.contract.getKey.call(A,A_p,B,B_p,C,C_p,H,K,input,account_one,1001);
          //console.log(check1);
          //////////////////////////////////Below are tests if it has been minted correcrtly or not///////////////////////////////////////
          let total = await this.contract.totalSupply();
          assert.equal(total,1, 'The total supply is incorrect');
          let tokenURI = await this.contract.tokenURI(1001);
          assert.equal(tokenURI,'https://s3-us-west-2.amazonaws.com/udacity-blockchain/capstone/1001', 'the tokenURI is incorrect for account 1001');
          let balanceAcc = await this.contract.balanceOf(account_one);
          assert.equal(balanceAcc,1, 'the balance is incorrect for account_one');

        })

        it('Tests solution cannot be added if the proof used previously', async function () {

          let A = proof.proof.A;
          let A_p = proof.proof.A_p;
          let B = proof.proof.B;
          let B_p = proof.proof.B_p;
          let C = proof.proof.C;
          let C_p = proof.proof.C_p;
          let H = proof.proof.H;
          let K = proof.proof.K;
          let input = proof.input;

          await this.contract.addSolutionAndMint(A,A_p,B,B_p,C,C_p,H,K,input,account_one,1001); //// first we add the solution
          let check = await this.contract.addSolutionAndMint(A,A_p,B,B_p,C,C_p,H,K,input,account_one,1001); /// second time with the same proof, the solution cannot be added again
          truffleAssert.eventNotEmitted(check, 'solutionAdded');


        })



    });

})
